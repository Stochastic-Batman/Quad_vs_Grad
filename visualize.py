import io
import logging
import matplotlib
import numpy as np
matplotlib.use('Agg')
import matplotlib.patheffects as pe
import matplotlib.pyplot as plt

from matplotlib.lines import Line2D
from pathlib import Path
from PIL import Image

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s  (%(levelname)s): %(message)s', datefmt='%d/%m/%Y %H:%M:%S',)
logger = logging.getLogger(Path(__file__).stem + "Logger")

# Below this, everything was generated by Grok 4.1 Expert

_CONTOUR_LEVELS = 60
_GRID_RES = 200
_MARGIN = 0.4
_FIG_SIZE = (8, 6.5)
_CMAP = 'RdYlGn_r'


def compute_loss_grid(
    H_fixed: np.ndarray,
    y_np: np.ndarray,
    v1_range: np.ndarray,
    v2_range: np.ndarray,
) -> np.ndarray:
    V1, V2 = np.meshgrid(v1_range, v2_range)
    params = np.stack([V1.ravel(), V2.ravel()], axis=1)
    logits = H_fixed @ params.T
    preds = np.clip(1.0 / (1.0 + np.exp(-logits)), 1e-7, 1.0 - 1e-7)
    loss = -np.mean(
        y_np[:, None] * np.log(preds) + (1.0 - y_np[:, None]) * np.log(1.0 - preds),
        axis=0,
    )
    return loss.reshape(V1.shape)


def _path_bounds(
    paths: list[list[np.ndarray]],
) -> tuple[float, float, float, float]:
    all_pts = np.vstack([np.vstack(p) for p in paths])
    v1_min, v2_min = all_pts.min(axis=0) - _MARGIN
    v1_max, v2_max = all_pts.max(axis=0) + _MARGIN
    return float(v1_min), float(v1_max), float(v2_min), float(v2_max)


def _draw_landscape(
    ax: plt.Axes,
    Z: np.ndarray,
    v1_range: np.ndarray,
    v2_range: np.ndarray,
) -> None:
    cf = ax.contourf(v1_range, v2_range, Z, levels=_CONTOUR_LEVELS, cmap=_CMAP, alpha=0.85)
    ax.contour(v1_range, v2_range, Z, levels=20, colors='white', linewidths=0.25, alpha=0.35)
    plt.colorbar(cf, ax=ax, label='BCE Loss', pad=0.02)


def _draw_path(
    ax: plt.Axes,
    path: list[np.ndarray],
    color: str,
    name: str,
    frame: int | None = None,
) -> None:
    pts = np.vstack(path) if frame is None else np.vstack(path[: frame + 1])
    n = len(pts)

    if n > 1:
        for i in range(n - 1):
            alpha = 0.35 + 0.65 * (i / max(n - 2, 1))
            ax.plot(
                pts[i : i + 2, 0], pts[i : i + 2, 1],
                color=color, linewidth=2.0, alpha=alpha, solid_capstyle='round',
            )

    ax.scatter(
        pts[0, 0], pts[0, 1], marker='o', s=90, color=color,
        edgecolors='white', linewidths=1.2, zorder=5,
        path_effects=[pe.withStroke(linewidth=2.5, foreground='white')],
    )
    ax.scatter(
        pts[-1, 0], pts[-1, 1], marker='*', s=200, color=color,
        edgecolors='white', linewidths=1.2, zorder=5,
        path_effects=[pe.withStroke(linewidth=2.5, foreground='white')],
    )


def _style_axes(
    ax: plt.Axes,
    names: list[str],
    colors: list[str],
    title: str,
) -> None:
    ax.set_xlabel('v₁  (output weight 1)', fontsize=11)
    ax.set_ylabel('v₂  (output weight 2)', fontsize=11)
    ax.set_title(title, fontsize=13, fontweight='bold', pad=10)
    legend_handles = [
        Line2D([0], [0], color=c, linewidth=2.5, label=n)
        for n, c in zip(names, colors)
    ]
    legend_handles += [
        Line2D([0], [0], marker='o', color='none', markerfacecolor='grey',
               markersize=7, label='start'),
        Line2D([0], [0], marker='*', color='none', markerfacecolor='grey',
               markersize=10, label='end'),
    ]
    ax.legend(handles=legend_handles, loc='upper right', fontsize=9,
              framealpha=0.75, edgecolor='none')
    ax.tick_params(labelsize=9)


def save_static_plot(
    H_fixed: np.ndarray,
    y_np: np.ndarray,
    paths: list[list[np.ndarray]],
    names: list[str],
    colors: list[str],
    output_path: str = 'paths.png',
) -> None:
    v1_min, v1_max, v2_min, v2_max = _path_bounds(paths)
    v1_range = np.linspace(v1_min, v1_max, _GRID_RES)
    v2_range = np.linspace(v2_min, v2_max, _GRID_RES)
    Z = compute_loss_grid(H_fixed, y_np, v1_range, v2_range)

    fig, ax = plt.subplots(figsize=_FIG_SIZE)
    _draw_landscape(ax, Z, v1_range, v2_range)
    for path, color in zip(paths, colors):
        _draw_path(ax, path, color, name='')
    step_counts = '  |  '.join(f"{n}: {len(p)-1} steps" for n, p in zip(names, paths))
    _style_axes(ax, names, colors, f"Optimization Paths on BCE Loss Surface\n{step_counts}")

    fig.tight_layout()
    fig.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close(fig)
    logger.info("Saved static plot -> %s", output_path)


def save_animation(
    H_fixed: np.ndarray,
    y_np: np.ndarray,
    paths: list[list[np.ndarray]],
    names: list[str],
    colors: list[str],
    output_path: str = 'journey.gif',
    fps: int = 12,
) -> None:
    v1_min, v1_max, v2_min, v2_max = _path_bounds(paths)
    v1_range = np.linspace(v1_min, v1_max, _GRID_RES)
    v2_range = np.linspace(v2_min, v2_max, _GRID_RES)
    Z = compute_loss_grid(H_fixed, y_np, v1_range, v2_range)

    max_steps = max(len(p) for p in paths)
    padded = [
        p + [p[-1]] * (max_steps - len(p)) for p in paths
    ]

    frames: list[Image.Image] = []
    frame_indices = list(range(0, max_steps, max(1, max_steps // 80)))
    if frame_indices[-1] != max_steps - 1:
        frame_indices.append(max_steps - 1)

    for frame in frame_indices:
        fig, ax = plt.subplots(figsize=_FIG_SIZE)
        _draw_landscape(ax, Z, v1_range, v2_range)
        for path, color, name in zip(padded, colors, names):
            _draw_path(ax, path, color, name, frame=frame)
        _style_axes(ax, names, colors, f"Step {frame}  /  {max_steps - 1}")

        fig.tight_layout()
        buf = io.BytesIO()
        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        plt.close(fig)
        buf.seek(0)
        frames.append(Image.open(buf).copy())
        buf.close()

    duration_ms = int(1000 / fps)
    frames[0].save(
        output_path,
        save_all=True,
        append_images=frames[1:],
        loop=0,
        duration=duration_ms,
    )
    logger.info("Saved animation  -> %s  (%d frames, %d fps)", output_path, len(frames), fps)